import os
import subprocess
import osxbundle

googletest_framework_root = "../ext/googletest-release-1.8.0"

googletest_include_paths = [
    googletest_framework_root + "/googletest",
    googletest_framework_root + "/googletest/include",
    googletest_framework_root + "/googlemock",
    googletest_framework_root + "/googlemock/include"
]

gtest_all_path = googletest_framework_root + "/googletest/src/gtest-all.cc"
gmock_all_path = googletest_framework_root + "/googlemock/src/gmock-all.cc"

def get_qt_install_prefix():
    qt_dir = None

    try:
        qmake_output = subprocess.check_output(['qmake', '-query'])

        string_qmake = qmake_output.decode('utf-8')
        lines = string_qmake.split(os.linesep)
    
        for line in lines:
            (key, value) = line.split(':', 1)
            if key == 'QT_INSTALL_PREFIX':
                qt_dir = value
                break
    except Exception as e:
        print("Failed to run qmake.")

    return qt_dir


qt5_dir = ARGUMENTS.get('qt5_dir')

print("using qt5 dir ", qt5_dir)

if (qt5_dir is None):
    qt5_dir = get_qt_install_prefix()

if (qt5_dir is None):
    raise Exception(
        "Unable to locate the Qt directory, try using qt5_dir=THEDIR on the "
        + "command line."
    )

general_ext_include_path = '../ext'
xlnt_include_path = "ext/xlnt-1.2.0/include"

linkflags = []
ccflags = []
libs = []


env = Environment(
    tools=['default', 'qt5'],
    QT5DIR=qt5_dir,
    CPPPATH=googletest_include_paths + [xlnt_include_path, general_ext_include_path]
)

env['QT5_DEBUG'] = 1

maybe_term = os.environ.get('TERM')
if maybe_term:
    env['ENV']['TERM'] = maybe_term


maybe_pkg_config_path = os.environ.get('PKG_CONFIG_PATH')
if maybe_pkg_config_path:
    env['ENV']['PKG_CONFIG_PATH'] = maybe_pkg_config_path

env.EnableQt5Modules(['QtCore', 'QtWidgets', 'QtNetwork'])

if env['PLATFORM'] == 'win32':
    ccflags = [
        '/EHsc',    # unbreak exceptions
        '/MD'       # dynamically link against VC++ CRT
    ]
    linkflags = [
        '/subsystem:windows'    # do not spawn a console window
    ]
    libs = [
	'shell32',    # /subsystem:windows requires this
	'xlnt'
    ]
else:
    ccflags = ['-fPIC', '-std=c++11']
    libs = ['pthread', 'xlnt']

env.Append(CCFLAGS=ccflags)
env.Append(LIBS=libs)
env.Append(LINKFLAGS=linkflags)

print("Prog emitter:", env['PROGEMITTER'])
print("Program is" + repr(env['BUILDERS']['Program'].emitter))


env.Program(
    target='unit_tests',
    source=[
        "utility_test.cc",
        "progress_reporter.cc",
        "settings.cc",
        "file_info_test.cc",
        "file_info.cc",
        "requests.cc",
        "figshare_gateway_test.cc",
        "figshare_gateway.cc",
        "license_test.cc",
        "article_type_mapper.cc",
        "token_store.cc",
        "article_type_mapper_test.cc",
        "article_mapper.cc",
        "path_extractor_test.cc",
        "path_extractor.cc",
        "category_test.cc",
        "category_mapper.cc",
        "stubs.cc",
        "md5_test.cc",
        "file_spec_generator.cc",
        "mapper_test.cc",
        "xlsx_test.cc",
        "part_preparer_test.cc",
        "part_preparer.cc",
        "file_part.cc",
        "upload_command.cc",
        "http_putter.cc",
        "upload_command_processor.cc",
        "upload_command_processor_test.cc",
        "fake_qt_core_application.cc",
        "http_getter.cc",
        "http_poster.cc",
        "http_getter_test.cc",
        "http_poster_test.cc",
        "xlsx.cc",
        "size_getter_integration_test.cc",
        "size_getter.cc",
        "requests_test.cc",
        "upload_container_info_test.cc",
        "upload_container_info.cc",
        "file_part_test.cc",
        "responses_test.cc",
        "responses.cc",
        "driver_test.cc",
        "driver.cc",
        "object_mother.cc",
        "http_getter.cc",
        "http_poster.cc",
        "test_utility.cc",
        "utility.cc",
        "test_harness.cc",
        gtest_all_path, gmock_all_path
    ]
)

env.Program(
    target='main',
    source=[
        "progress_reporter.cc",
        "settings.cc",
        "main.cc", "view.cc", "presenter.cc", "run_upload_task.cc",
        "driver_thread.cc",
        "file_info.cc",
        "requests.cc",
        "figshare_gateway.cc",
        "article_type_mapper.cc",
        "article_mapper.cc",
        "category_mapper.cc",
        "file_spec_generator.cc",
        "token_store.cc",
        "part_preparer.cc",
        "file_part.cc",
        "upload_command.cc",
        "http_putter.cc",
        "upload_command_processor.cc",
        "http_getter.cc",
        "http_poster.cc",
        "xlsx.cc",
        "size_getter.cc",
        "upload_container_info.cc",
        "responses.cc",
        "progress_reporter.cc",
        "driver.cc",
        "path_extractor.cc",
        "utility.cc"
    ]
)

# We have to use a fresh environment for the bundling process.
def do_bundle():
    bundle_env = Environment()
    osxbundle.TOOL_BUNDLE(bundle_env)

    bundledir = "the_bundle.app"
    app = "main"
    key = "uk.ac.sussex"

    # We use the initial hash-sign to refer to a path relative to the root
    # directory of the source checkout.
    info_plist = "#info_plist.xml"
    
    # This is a kind of quirk of bundles, it's just some unused metadata.
    # APPL, on the other hand, is required
    typecode = "APPL"
    creator = "SUSX"

    icon_file = "icon.png"

    subst_dict = {
        '%SHORTVERSION%': '0.0.2',
        '%BUNDLE_EXECUTABLE%': app,
        '%BUNDLE_KEY%': key,
        '%ICONFILE%': icon_file,
        '%TYPE%': typecode
    }

    bundle_env.MakeBundle(
        bundledir, app, key, info_plist, typecode=typecode, creator=creator,
        subst_dict=subst_dict, resources=[icon_file]
    )

    macdeployqt_path = os.path.join(qt5_dir, 'bin', 'macdeployqt')


    # We expect to find xlnt installed under /usr/local/lib, this is not the
    # best assumption.
    env.Command(
        'the_bundle.dmg', 'the_bundle.app',
        "%s $SOURCE -dmg -libpath=/usr/local/lib"  % (macdeployqt_path,)
    )
    

if env['PLATFORM'] == 'darwin':
    print("Detected Mac OS X -- creating application bundle")
    do_bundle()
